<html>
<head>
</head>
<body>
    <canvas id="canvas" style="border: 1px solid black;"></canvas>
    <script>
        "use strict";


        //////////////////////
        // Config constants //
        //////////////////////

        var VIEWPORT_WIDTH_PIXELS = 900;    //How many pixels wide the viewport is
        var VIEWPORT_HEIGHT_PIXELS = 600;   //How many pixels tall the viewport is
        var VIEWPORT_WIDTH_DEGREES = 75;    //How wide the player can see (between 1 and 179 degrees)
        var COLUMN_WIDTH_PIXELS = 1;        //How wide each "drawn" line is (1 is highest resolution)
        var MAX_FRAMERATE = 45;             //The framerate the graphics engine will target
        var WALL_HEIGHT = 1;                //How tall each wall should be (1 is a cube)
        var SKY_COLOR = "#0000FF";          //Hex color of the sky
        var GROUND_COLOR = "#00FF00";       //Hex color of the ground
        var WALL_COLORS = ["#999999", "#990000", '#706030']; //Hex colors of the different wall types
        var WALL_SHADING_PERCENT = -15;     //Color difference of perpendicular walls
        var WALL_DISTANCE_SHADE = -.85;     //How much darker far away objects should appear
        var PLAYER_TURNING_SPEED = .002;    //How fast the player turns
        var PLAYER_WALKING_SPEED = .01;     //How fast the player walks       
        var PLAYER_STARTING_X = 8;          //Player's starting X location
        var PLAYER_STARTING_Y = 2;          //Player's starting Y location
        var PLAYER_STARTING_ANGLE_DEGREES = 90;             //Direction player is looking at start
        var PLAYER_CROSSHAIR_SIZE_PIXELS = 10;              //The height and width of the crosshairs
        var PLAYER_CROSSHAIR_COLOR = "#000000";             //The color of the crosshairs
        var TETRIS_STARTING_TICK_SPEED_MILLISECONDS = 2000; //The initial speed of the tetris engine
        var TETRIS_STARTING_LEVEL = 0;                      //The initial level of the tetris engine
        var TETRIS_SPEED_PER_LEVEL_MILLISECONDS = 100;      //How much the tetris tick speed decreases each level
        var TETRIS_DROP_TICK_SPEED_MILLISECONDS = 10;       //The tetris tick speed when pieces are dropping
        var TETRIS_PIECES = [[[2,2],[2,2]],                 //An array of the possible tetris pieces
                            [[2,2,2,2]],
                            [[0,2,2],[2,2,0]],
                            [[2,2,0],[0,2,2]],
                            [[2,2,2],[2,0,0]],
                            [[2,2,2],[0,0,2]],
                            [[2,2,2],[0,2,0]]];  

        
        //////////////////////
        // Global variables //
        //////////////////////

        var world = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];


        /////////////////////////
        // Initialization code //
        /////////////////////////
        
        (function () {
            var worldEngine = new WorldEngine();
            var tetrisEngine = new TetrisEngine();
            attachKeyboardListeners(worldEngine, tetrisEngine);
        })();


        /////////////////////////////////////
        // World engine (drawing & moving) //
        /////////////////////////////////////

        function WorldEngine() {
            var self = this;


            //-- PRIVATE MEMBER CONSTANTS --//

            var VERTICAL_WALL_COLORS = WALL_COLORS.map(function (color) { return shadeColor(color, WALL_SHADING_PERCENT); });   
            var WORLD_TICK_DELAY = 1000 / MAX_FRAMERATE;
            var WORLD_LENGTH_X = world[0].length;
            var WORLD_LENGTH_Y = world.length;
            var HALF_VIEWPORT_ANGLE_RADIANS = (VIEWPORT_WIDTH_DEGREES - 180) * Math.PI / -360;
            var VIEWPORT_DIST = Math.tan(HALF_VIEWPORT_ANGLE_RADIANS) * .5;         
            

            //-- PRIVATE MEMBER VARIABLES --//

            var playerX = PLAYER_STARTING_X;
            var playerY = PLAYER_STARTING_Y;
            var playerA = PLAYER_STARTING_ANGLE_DEGREES * 2 * Math.PI / 360;


            //-- PUBLIC MEMBER VARIABLES --//
            
            self.isMovingForward = false;
            self.isMovingBackward = false;
            self.isSidesteppingLeft = false;
            self.isSidesteppingRight = false;
            self.isTurningLeft = false;
            self.isTurningRight = false;


            //-- CONSTRUCTOR CODE --//

            (function () {
                var canvasContext = initializeAndGetCanvasContext();
                executeAndScheduleTick(new Date().valueOf(), canvasContext);
            })();


            //-- PUBLIC METHODS --//

            self.isFacingWallType = function (wallType) {
                var firstHit = getFirstHit(playerA);
                return firstHit.wallType === wallType;
            };

            self.isFacingRight = function () {
                return (playerA > (3/2)*Math.PI)
                    || (playerA < (1/2)*Math.PI);
            }

            self.isFacingUp = function () {
                return playerA > Math.PI;
            }


            //-- PRIVATE METHODS --//
            
            function executeAndScheduleTick(lastTickTime, canvasContext) {

                //Schedule next tick
                var currentTickTime = new Date().valueOf();
                setTimeout(function () {
                    executeAndScheduleTick(currentTickTime, canvasContext); 
                }, WORLD_TICK_DELAY);
                var elapsedTime = currentTickTime - lastTickTime;

                //Draw
                drawScreen(canvasContext);

                //Move
                movePlayer(elapsedTime);
            }
            
            function initializeAndGetCanvasContext() {
                var canvas = document.getElementById("canvas");
                canvas.setAttribute("width", VIEWPORT_WIDTH_PIXELS);
                canvas.setAttribute("height", VIEWPORT_HEIGHT_PIXELS);
                var context = canvas.getContext("2d");
                context.lineWidth = COLUMN_WIDTH_PIXELS;
                return context;
            }

            function drawScreen(canvasContext) {

                //For each viewport column
                for (var col = 0; col < VIEWPORT_WIDTH_PIXELS; col += COLUMN_WIDTH_PIXELS) {

                    //Get angle
                    var angleRelativeToPlayer = Math.atan((.5 - col / VIEWPORT_WIDTH_PIXELS) / VIEWPORT_DIST);
                    var angleRelativeToWorld = playerA + angleRelativeToPlayer;

                    //Get wall hit
                    var firstHit = getFirstHit(angleRelativeToWorld)
                    var firstHitDist = firstHit.dist;
                    var firstHitWallType = firstHit.wallType;
                    var isFirstHitHorizontalWall = firstHit.isHorizontalWall;

                    //Correct distortion due to flat viewport
                    var distFromViewport = firstHitDist * Math.cos(angleRelativeToPlayer);

                    //Get wall height on viewport
                    var wallHeightOnViewport;
                    if (distFromViewport != 0)
                        wallHeightOnViewport = WALL_HEIGHT * VIEWPORT_HEIGHT_PIXELS / distFromViewport;
                    else
                        wallHeightOnViewport = VIEWPORT_HEIGHT_PIXELS;
                    if (wallHeightOnViewport > VIEWPORT_HEIGHT_PIXELS)
                        wallHeightOnViewport = VIEWPORT_HEIGHT_PIXELS;

                    //Draw column
                    drawColumn(canvasContext, col, wallHeightOnViewport, firstHitWallType, isFirstHitHorizontalWall, distFromViewport * WALL_DISTANCE_SHADE);
                }

                //Draw overhead
                for (var row = 0; row < world.length; row++) {
                    for (var col = 0; col < world[0].length; col++) {
                        var color = world[row][col] == 0 ? "#FFFFFF" : WALL_COLORS[world[row][col] - 1];
                        canvasContext.fillStyle = color;
                        canvasContext.fillRect(col * 10, VIEWPORT_HEIGHT_PIXELS - row * 10 - 10, 10, 10);
                        canvasContext.stroke();
                    }
                }

                //Draw crosshairs
                canvasContext.fillStyle = PLAYER_CROSSHAIR_COLOR;
                canvasContext.fillRect(VIEWPORT_WIDTH_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2 - PLAYER_CROSSHAIR_SIZE_PIXELS / 2, 1, PLAYER_CROSSHAIR_SIZE_PIXELS);
                canvasContext.fillRect(VIEWPORT_WIDTH_PIXELS / 2 - PLAYER_CROSSHAIR_SIZE_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2, PLAYER_CROSSHAIR_SIZE_PIXELS, 1);
                canvasContext.stroke();
            }

            function getFirstHit(angle) {
                var hitX = getFirstHitForDirection(angle, false);
                var hitY = getFirstHitForDirection(angle, true);
                var isFirstHitHorizontalWall = hitY.dist < hitX.dist;
                return isFirstHitHorizontalWall ? hitY : hitX;
            }

            function getFirstHitForDirection(angle, onHorizontalWalls) {

                //configure direction
                if (onHorizontalWalls) {
                    var divisorToGetDist = Math.sin(angle);
                    var primaryCoordinate = playerY;
                    var secondaryCoordinate = playerX;
                    var multiplierToGetSecondary = 1 / Math.tan(angle);
                    var primaryMaxLength = WORLD_LENGTH_Y;
                    var secondaryMaxLength = WORLD_LENGTH_X;
                    var getWallTypeAtIntLocation = function () { return world[primaryInt + primaryWorldOffset][secondaryInt]; };
                }
                else {
                    var divisorToGetDist = Math.cos(angle);
                    var primaryCoordinate = playerX;
                    var secondaryCoordinate = playerY;
                    var multiplierToGetSecondary = Math.tan(angle);
                    var primaryMaxLength = WORLD_LENGTH_X;
                    var secondaryMaxLength = WORLD_LENGTH_Y;
                    var getWallTypeAtIntLocation = function () { return world[secondaryInt][primaryInt + primaryWorldOffset]; };
                }

                //Look for first hit
                if (divisorToGetDist != 0) {
                    var angleIsPositive = divisorToGetDist >= 0;
                    var firstPrimaryInt = angleIsPositive ? Math.ceil(primaryCoordinate) : Math.floor(primaryCoordinate);
                    var intStep = angleIsPositive ? 1 : -1;
                    var primaryWorldOffset = angleIsPositive ? 0 : -1;

                    //Test each grid intercept
                    for (var primaryInt = firstPrimaryInt ; primaryInt < primaryMaxLength; primaryInt += intStep) {
                        var primaryDist = primaryInt - primaryCoordinate;
                        var secondaryInt = Math.floor(secondaryCoordinate + primaryDist * multiplierToGetSecondary);

                        //If a hit
                        if (secondaryInt <= 0 || secondaryInt >= secondaryMaxLength || primaryInt <= 0 || primaryInt >= primaryMaxLength) {
                            break;
                        }
                        else if (getWallTypeAtIntLocation() !== 0) {
                            var distHit = primaryDist / divisorToGetDist;

                            //Return hit object
                            return { 
                                dist: distHit, 
                                wallType: getWallTypeAtIntLocation(), 
                                isHorizontalWall: onHorizontalWalls
                            };
                        }
                    }
                }

                //No hit found
                return { 
                    dist: Infinity,
                    wallType: null,
                    horizontalWall: onHorizontalWalls
                };
            }

            function drawColumn(canvasContext, col, wallHeight, wallType, isHorizontalWall, wallShade) {
                var wallTop = (VIEWPORT_HEIGHT_PIXELS - wallHeight) / 2;
                var wallBottom = VIEWPORT_HEIGHT_PIXELS - wallTop;
                drawLine(canvasContext, col, 0, col, wallTop, SKY_COLOR);
                drawLine(canvasContext, col, wallTop, col, wallBottom, shadeColor(isHorizontalWall ? WALL_COLORS[wallType - 1] : VERTICAL_WALL_COLORS[wallType - 1], wallShade));
                drawLine(canvasContext, col, wallBottom, col, VIEWPORT_HEIGHT_PIXELS, GROUND_COLOR);
            }

            function drawLine(canvasContext, x1, y1, x2, y2, color) {
                canvasContext.beginPath();
                canvasContext.strokeStyle = color;
                canvasContext.moveTo(x1, y1);
                canvasContext.lineTo(x2, y2);
                canvasContext.stroke();
            }

            function movePlayer(elapsedTime) {

                //Turning left
                if (self.isTurningLeft)
                    playerA += PLAYER_TURNING_SPEED * elapsedTime;

                //Turning right
                if (self.isTurningRight)
                    playerA -= PLAYER_TURNING_SPEED * elapsedTime;

                //Normalize angle
                if (playerA < 0)
                    playerA += 2 * Math.PI;
                playerA %= 2 * Math.PI;

                //Forward
                if (self.isMovingForward) {
                    tryMove(playerA, PLAYER_WALKING_SPEED * elapsedTime);
                }

                //Backward
                if (self.isMovingBackward) {
                    tryMove(playerA + Math.PI, PLAYER_WALKING_SPEED * elapsedTime);
                }

                //Sidestepping left
                if (self.isSidesteppingLeft) {
                    tryMove(playerA + (Math.PI / 2), PLAYER_WALKING_SPEED * elapsedTime);
                }

                //Sidestepping Right
                if (self.isSidesteppingRight) {
                    tryMove(playerA - (Math.PI / 2), PLAYER_WALKING_SPEED * elapsedTime);
                }
            }

            function tryMove(angle, walkDistance) {

                //Get distances
                var distX = Math.cos(angle) * walkDistance;
                var distY = Math.sin(angle) * walkDistance;

                //Get hits
                var hitX = getFirstHitForDirection(angle, false);
                var hitY = getFirstHitForDirection(angle, true);

                //Try move straight
                if (hitX.dist >= walkDistance && hitY.dist >= walkDistance) {
                    playerX += distX;
                    playerY += distY;
                }
                    //Try move along wall
                else if (hitX.dist < hitY.dist) {
                    if (distY > 0)
                        tryMove(Math.PI / 2, distY);
                    else
                        tryMove(3 * Math.PI / 2, -distY);
                }
                else {
                    if (distX > 0)
                        tryMove(0, distX);
                    else
                        tryMove(Math.PI, -distX);
                }
            }
            
            function shadeColor(color, percent) {
                //From: http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
                var num = parseInt(color.slice(1), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        };

        
        ///////////////////
        // Tetris engine //
        ///////////////////

        function TetrisEngine() {
            var self = this;


            //-- PRIVATE MEMBER VARIABLES --//

            var lastTickIndex = 0;
            var tickDelay = TETRIS_STARTING_TICK_SPEED_MILLISECONDS;
            var numberOfLines = 0;
            var currentLevel = TETRIS_STARTING_LEVEL;


            //-- CONSTRUCTOR CODE --//

            (function () {
                addBlock();
                scheduleTick(0);
            })();


            //-- PUBLIC METHODS --//

            self.moveLeft = function () {
                console.log("Move Tetris piece left.");
                if(!isLeftACollision()){
                //TODO: we need to make sure it doesn't go through existing blocks too.
                // check from the left, and see if there are empty spaces to the left.
                    for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                        for(var cellIndex =0; cellIndex < world[rowIndex].length; cellIndex++){
                            var currentCell = world[rowIndex][cellIndex];

                            if(currentCell == 2){
                                world[rowIndex][cellIndex-1] = 2; //move it 'left'
                                world[rowIndex][cellIndex] = 0; //displace the old cell
                            }
                        }
                    }
                }
            }

            self.moveRight = function () {
                console.log("Move Tetris piece right.");
                if(!isRightACollision()){
                    //if(world.map((a)=>a[10]).indexOf(2) == -1){ //check if we will hit the right side
                    for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                        for(var cellIndex = world[rowIndex].length; cellIndex >= 0; cellIndex--){ //starts from the right side of each array
                            var currentCell = world[rowIndex][cellIndex];
                            if(currentCell == 2){
                                world[rowIndex][cellIndex+1] = 2; //move it 'right'
                                world[rowIndex][cellIndex] = 0; //displace the old cell
                            }
                        }
                    }
                }
            }

            self.rotate = function (angle) { //positive is clockwise, negative is anticlockwise
                console.log("Rotate Tetris piece.");          
            }

            self.drop = function () {

                //Set speed
                if (tickDelay > TETRIS_DROP_TICK_SPEED_MILLISECONDS)
                    tickDelay = TETRIS_DROP_TICK_SPEED_MILLISECONDS;

                //Immediately initiate tetris tick
                scheduleTick(0);
            }


            //-- PRIVATE METHODS --//

            function executeAndScheduleTick(initiatingTickIndex) {
                if (initiatingTickIndex === lastTickIndex) {
                    scheduleTick(tickDelay);
                    
                    if(isMovingDownACollision()){
                        setPiece();
                        clearLines();
                        updateSpeedIfNecessary();
                        addBlock();
                        scheduleTick(tickDelay);
                    }
                    else{
                        movePieceDown();
                    }
                }
            }

            function scheduleTick(delay) {            
                var currentTickIndex = lastTickIndex + 1;
                lastTickIndex = currentTickIndex;            
                setTimeout(function () { executeAndScheduleTick(currentTickIndex); }, delay);
            }

            function addBlock(){
                var newBlock = TETRIS_PIECES[Math.floor(Math.random()*(TETRIS_PIECES.length))]; //shuffle the pieces and grab one
                var length = newBlock[0].length;
                var startingCell = (10/2)-Math.floor(length/2);
                for(var rowIndex = 0; rowIndex < newBlock.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex < newBlock[rowIndex].length; cellIndex++){
                        world[world.length-2-rowIndex][startingCell+cellIndex] = newBlock[rowIndex][cellIndex];
                    }                    
                }
            }

            function movePieceDown(){
                //nothing colides, so we can move it down;
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    for(var cellIndex =0; cellIndex < world[rowIndex].length; cellIndex++){
                        var currentCell = world[rowIndex][cellIndex];
                        if(currentCell == 2){
                            world[rowIndex-1][cellIndex] = 2; //move it 'down'
                            world[rowIndex][cellIndex] = 0; //displace the old cell
                        }
                    }
                }
            }

            function setPiece(){
                //turn all 2's into 3's
                //maybe we can do madness here, and convert the array to string and replace all the 2's with 3's
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex < world[rowIndex].length; cellIndex++){
                        var currentCell = world[rowIndex][cellIndex];
                        if(currentCell == 2){
                            world[rowIndex][cellIndex] = 3;
                        }
                    }
                }
            }            

            function clearLines(){
                //find all the 2's and move them 'plus' one level in the array
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    if(world[rowIndex].reduce((a,b)=>a+b,0)== 32){ //row is [1,3,3,3,3,3,3,3,3,3,3,1], sums to 32
                        //maybe we can flash the row a special color?
                        world.splice(rowIndex,1);  //remove that row
                        world.splice(20,0,[1,0,0,0,0,0,0,0,0,0,0,1]); //push a blank row at top
                        
                        //add a line, and maybe speed up
                        numberOfLines++;
                        if(numberOfLines >= ((currentLevel*10)+10)){
                            currentLevel++;
                        }
                    }
                }
            }

            function isMovingDownACollision(){
                //find all the 2's and move them 'plus' one level in the array
                var collision = false;
                for(var rowIndex = world.length-1; rowIndex > 0; rowIndex--){ //start at the last row and work up
                    var currentRow = world[rowIndex];
                    for(var cellIndex = 0; cellIndex < currentRow.length; cellIndex++){
                        //for each cell, see if it's a 2, and if we can move it down.
                        if(currentRow[cellIndex] == 2){
                            var cellBelowCurrentCell = world[rowIndex-1][cellIndex];
                            if(cellBelowCurrentCell == 1 || // 1 is the wall
                                cellBelowCurrentCell == 3 ){ // 3 is the already set pieces;
                                    collision = true;
                                    return collision;
                                }
                        }
                    }
                }
                return collision;
            }

            function isLeftACollision(){
                //find all the 2's and move them 'plus' one level in the array
                var collision = false;
                for(var rowIndex = world.length-1; rowIndex > 0; rowIndex--){ //start at the last row and work up
                    var currentRow = world[rowIndex];
                    for(var cellIndex = 1; cellIndex < currentRow.length; cellIndex++){
                        if(currentRow[cellIndex] == 2){
                            var cellLeftOfCurrentCell = world[rowIndex][cellIndex-1];
                            if(cellLeftOfCurrentCell == 1 || // 1 is the wall
                                cellLeftOfCurrentCell == 3 ){ // 3 is the already set pieces;
                                    collision = true;
                                    return collision;
                                }
                        }
                    }
                }
                return collision;
            }

            function isRightACollision(){
                //find all the 2's and move them 'plus' one level in the array
                var collision = false;
                for(var rowIndex = world.length-1; rowIndex > 0; rowIndex--){ //start at the last row and work up
                    var currentRow = world[rowIndex];
                    for(var cellIndex = currentRow.length+1; cellIndex > 0; cellIndex--){
                        if(currentRow[cellIndex] == 2){
                            var cellRightOfCurrentCell = world[rowIndex][cellIndex+1];
                            if(cellRightOfCurrentCell == 1 || // 1 is the wall
                                cellRightOfCurrentCell == 3 ){ // 3 is the already set pieces;
                                    collision = true;
                                    return collision;
                                }
                        }
                    }
                }
                return collision;
            }

            function updateSpeedIfNecessary() {
                //updates the speed, used when dropping stops, and when the level goes up.
                tickDelay = TETRIS_STARTING_TICK_SPEED_MILLISECONDS - (currentLevel * TETRIS_SPEED_PER_LEVEL_MILLISECONDS);
            }
        }                    


        ///////////////////////
        // Keyboard handling //
        ///////////////////////

        function attachKeyboardListeners(worldEngine, tetrisEngine) {

            //Key down
            document.onkeydown = function (keyboardEvent) { console.log(String.fromCharCode(keyboardEvent.keyCode));
                switch (String.fromCharCode(keyboardEvent.keyCode)) {
                    case "W":
                        worldEngine.isMovingForward = true;
                        break;
                    case "A":
                        worldEngine.isTurningLeft = true;
                        break;
                    case "Q":
                        worldEngine.isSidesteppingLeft = true;
                        break;
                    case "E":
                        worldEngine.isSidesteppingRight = true;
                        break;
                    case "S":
                        worldEngine.isMovingBackward = true;
                        break;
                    case "D":
                        worldEngine.isTurningRight = true;
                        break;
                    case "%":
                        if (worldEngine.isFacingWallType(2)) {
                            if (worldEngine.isFacingUp())
                                tetrisEngine.moveRight();
                            else
                                tetrisEngine.moveLeft();
                        }
                        break;
                    case "&":
                        if (worldEngine.isFacingWallType(2)) {
                            if (worldEngine.isFacingRight())
                                tetrisEngine.moveRight();
                            else
                                tetrisEngine.moveLeft();
                        }
                        break;
                    case "'":
                        if (worldEngine.isFacingWallType(2)) {
                            if (worldEngine.isFacingUp())
                                tetrisEngine.moveLeft();
                            else
                                tetrisEngine.moveRight();
                        }
                        break;
                    case "(":
                        if (worldEngine.isFacingWallType(2)) {
                            if (worldEngine.isFacingRight())
                                tetrisEngine.moveLeft();
                            else
                                tetrisEngine.moveRight();
                        }
                        break;
                    case "¿":
                        tetrisEngine.rotate();
                        break;
                    case " ":
                        if (worldEngine.isFacingWallType(2))
                            tetrisEngine.drop();
                        break;
                }
            }

            //Key up
            document.onkeyup = function (keyboardEvent) {
                switch (String.fromCharCode(keyboardEvent.keyCode)) {
                    case "W":
                        worldEngine.isMovingForward = false;
                        break;
                    case "A":
                        worldEngine.isTurningLeft = false;
                        break;
                    case "Q":
                        worldEngine.isSidesteppingLeft = false;
                        break;
                    case "E":
                        worldEngine.isSidesteppingRight = false;
                        break;
                    case "S":
                        worldEngine.isMovingBackward = false;
                        break;
                    case "D":
                        worldEngine.isTurningRight = false;
                        break;
                }
            }
        }
    </script>
</body>
</html>