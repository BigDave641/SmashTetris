<html>
<head>
</head>
<body style="margin: 0">
    <canvas id="canvas" style="border: 1px solid black;"></canvas>
    <script>
        "use strict";


        //////////////////////
        // Config constants //
        //////////////////////

        window.VIEWPORT_WIDTH_PIXELS = 900;    //How many pixels wide the viewport is
        window.VIEWPORT_HEIGHT_PIXELS = 600;   //How many pixels tall the viewport is
        window.VIEWPORT_WIDTH_DEGREES = 75;    //How wide the player can see (between 1 and 179 degrees)
        window.COLUMN_WIDTH_PIXELS = 1;        //How wide each "drawn" line is (1 is highest resolution)
        window.MAX_FRAMERATE = 45;             //The framerate the graphics engine will target
        window.WALL_HEIGHT = 1;                //How tall each wall should be (1 is a cube)
        window.SKY_COLOR = "#99d9ea";          //Hex color of the sky
        window.GROUND_COLOR = "#22b14c";       //Hex color of the ground
        window.WALL_COLORS = ["#999999", "#990000", '#00002d'];        //Hex colors of the different wall types
        window.WALL_COLORS_FACING = ["#999999", "#DD0000", '#00002d']; //Hex colors when the user is pointed at the wall
        window.WALL_SHADING_PERCENT = -15;     //Color difference of perpendicular walls
        window.WALL_DISTANCE_SHADE = -.85;     //How much darker far away objects should appear
        window.PLAYER_TURNING_SPEED = .002;    //How fast the player turns
        window.PLAYER_WALKING_SPEED = .01;     //How fast the player walks
        window.PLAYER_ACCELERATION = .0015;    //How fast the player accelerates
        window.PLAYER_STARTING_X = 8;          //Player's starting X location
        window.PLAYER_STARTING_Y = 4;          //Player's starting Y location
        window.PLAYER_STARTING_ANGLE_DEGREES = 90;             //Direction player is looking at start
        window.VIEWPORT_CROSSHAIR_SIZE_PIXELS = 10;            //The height and width of the crosshairs
        window.VIEWPORT_CROSSHAIR_COLOR = "#000000";           //The color of the crosshairs
        window.TETRIS_STARTING_TICK_SPEED_MILLISECONDS = 2000; //The initial speed of the tetris engine
        window.TETRIS_STARTING_LEVEL = 0;                      //The initial level of the tetris engine
        window.TETRIS_SPEED_PER_LEVEL_MILLISECONDS = 100;      //How much the tetris tick speed decreases each level
        window.TETRIS_DROP_TICK_SPEED_MILLISECONDS = 10;       //The tetris tick speed when pieces are dropping
        window.PLAYER_PUSHED_BUFFER = .001;
        window.WALL_TYPE_NONE = 0;
        window.WALL_TYPE_ARENA = 1;
        window.WALL_TYPE_PIECE_ACTIVE = 2;
        window.WALL_TYPE_PIECE_INACTIVE = 3;
        window.CONFIG_VALUE_WAIT_TIME_MILLISECONDS = 1000;
        window.TETRIS_S = {name:"S", 
                        initial: [[0,2,2],
                                  [2,2,0]],
                        rotations: [
                            [[2,2,0],
                             [0,2,2],
                             [0,0,0]],
                            [[0,0,2],
                             [0,2,2],
                             [0,2,0]],
                            [[2,2,0],
                             [0,2,2],
                             [0,0,0]],
                            [[0,0,2],
                             [0,2,2],
                             [0,2,0]]
                        ]};
        window.TETRIS_Z = {name:"Z", 
                        initial: [[2,2,0],
                                  [0,2,2]],
                        rotations: [
                            [[0,2,2],
                             [2,2,0],
                             [0,0,0]],
                            [[0,2,0],
                             [0,2,2],
                             [0,0,2]],
                            [[0,2,2],
                             [2,2,0],
                             [0,0,0]],
                            [[0,2,0],
                             [0,2,2],
                             [0,0,2]]
                        ]};
        window.TETRIS_O = {name:"O", 
                        initial: [[2,2],
                                  [2,2]],
                        rotations: []};
        window.TETRIS_L = {name:"L", 
                        initial: [[2,2,2],
                                  [2,0,0]],
                        rotations: [
                            [[2,0,0],
                             [2,2,2],
                             [0,0,0]],
                            [[0,2,2],
                             [0,2,0],
                             [0,2,0]],
                            [[0,0,0],
                             [2,2,2],
                             [0,0,2]],
                            [[0,2,0],
                             [0,2,0],
                             [2,2,0]]
                        ]};
        window.TETRIS_J = {name:"J", 
                        initial: [[2,2,2],
                                  [0,0,2]],
                        rotations: [
                            [[0,0,2],
                             [2,2,2],
                             [0,0,0]],
                            [[0,2,0],
                             [0,2,0],
                             [0,2,2]],
                            [[0,0,0],
                             [2,2,2],
                             [2,0,0]],
                            [[2,2,0],
                             [0,2,0],
                             [0,2,0]]
                        ]};
        window.TETRIS_T = {name:"T", 
                        initial: [[2,2,2],
                                  [0,2,0]],
                        rotations: [
                            [[0,2,0],
                             [2,2,2],
                             [0,0,0]],
                            [[0,2,0],
                             [0,2,2],
                             [0,2,0]],
                            [[0,0,0],
                             [2,2,2],
                             [0,2,0]],
                            [[0,2,0],
                             [2,2,0],
                             [0,2,0]]
                        ]};
        window.TETRIS_I = {name:"I", 
                        initial: [[2,2,2,2]],
                        rotations: [
                            [[2,2,2,2],
                             [0,0,0,0],
                             [0,0,0,0],
                             [0,0,0,0]],
                            [[2,0,0,0],
                             [2,0,0,0],
                             [2,0,0,0],
                             [2,0,0,0]],
                            [[2,2,2,2],
                             [0,0,0,0],
                             [0,0,0,0],
                             [0,0,0,0]],
                            [[2,0,0,0],
                             [2,0,0,0],
                             [2,0,0,0],
                             [2,0,0,0]]
                        ]};
         window.TETRIS_PIECES = [                               //An array of the possible tetris pieces
                            window.TETRIS_S,
                            window.TETRIS_Z,
                            window.TETRIS_I,                            
                            window.TETRIS_O,
                            window.TETRIS_L,
                            window.TETRIS_J,
                            window.TETRIS_T
                            ];       


        
        //////////////////////
        // Global variables //
        //////////////////////

        var world = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ]; //first row is bottom of world, left is left, right is right.
        var playerX;
        var playerY;
        var playerA;
        var isGameExecuting = false;


        /////////////////////////
        // Initialization code //
        /////////////////////////
        var tetris;

        (function () {        
            overrideConfigConstants()
                .then(function () {

                    //Set initial position
                    playerX = PLAYER_STARTING_X;
                    playerY = PLAYER_STARTING_Y;
                    playerA = PLAYER_STARTING_ANGLE_DEGREES * 2 * Math.PI / 360;

                    //Start engine
                    var raycastingEngine = new RaycastingEngine();
                    var tetrisEngine = new TetrisEngine();
                    tetris = tetrisEngine;
                    var playerEngine = new PlayerEngine(raycastingEngine, tetrisEngine);
                });
        })();

        

        ///////////////////
        // Player engine //
        ///////////////////

        function PlayerEngine(raycastingEngine, tetrisEngine) {
            var self = this;  


            //-- PRIVATE MEMBER CONSTANTS --//   

            var TICK_DELAY = 1000 / MAX_FRAMERATE;
            

            //-- PRIVATE MEMBER VARIABLES --//
           
            var isMovingForward = false;
            var isMovingBackward = false;
            var isSidesteppingLeft = false;
            var isSidesteppingRight = false;
            var isTurningLeft = false;
            var isTurningRight = false;
            var isDropping = false;
            var velocityX = 0;
            var velocityY = 0;
            

            //-- CONSTRUCTOR CODE --//
            
            (function () {
                tetrisEngine.pieceMovedDownCallback = pushPlayerDownIfNecessary;
                tetrisEngine.playerLostCallback = playerLostTetris;
                attachKeyboardListeners();                
                attachMouseListeners();
                executeAndScheduleTick(new Date().valueOf());
            })();


            //-- PRIVATE FUNCTIONALITY --//
            
            function executeAndScheduleTick(lastTickTime) {
                if (isGameExecuting) {

                    //Schedule next tick
                    var currentTickTime = new Date().valueOf();
                    setTimeout(function () {
                        executeAndScheduleTick(currentTickTime); 
                    }, TICK_DELAY);
                    var elapsedTime = currentTickTime - lastTickTime;

                    //Do player actions
                    dropPieceIfNecessary();
                    movePlayer(elapsedTime);
                }
            }

            function dropPieceIfNecessary() {
                if (isDropping && raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE)
                    tetrisEngine.drop();
                else
                    tetrisEngine.cancelDrop();
            }

            function movePlayer(elapsedTime) {

                //Turning
                if (isTurningLeft)
                    playerA += PLAYER_TURNING_SPEED * elapsedTime;
                if (isTurningRight)
                    playerA -= PLAYER_TURNING_SPEED * elapsedTime;

                //Normalize angle
                if (playerA < 0)
                    playerA += 2 * Math.PI;
                playerA %= 2 * Math.PI;

                //Decelerate
                var ratioToDecelerate = 1 - PLAYER_ACCELERATION / Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                if (ratioToDecelerate > 0) {
                    velocityX *= ratioToDecelerate;
                    velocityY *= ratioToDecelerate;
                }
                else {
                    velocityX = 0;
                    velocityY = 0;
                }

                //Accelerating
                if (isMovingForward) {
                    velocityY += 2 * PLAYER_ACCELERATION * Math.sin(playerA);
                    velocityX += 2 * PLAYER_ACCELERATION * Math.cos(playerA);
                }
                if (isMovingBackward) {
                    velocityY -= 2 * PLAYER_ACCELERATION * Math.sin(playerA);
                    velocityX -= 2 * PLAYER_ACCELERATION * Math.cos(playerA);
                }
                if (isSidesteppingLeft) {
                    velocityY += 2 * PLAYER_ACCELERATION * Math.sin(playerA + Math.PI / 2);
                    velocityX += 2 * PLAYER_ACCELERATION * Math.cos(playerA + Math.PI / 2);
                }
                if (isSidesteppingRight) {
                    velocityY -= 2 * PLAYER_ACCELERATION * Math.sin(playerA + Math.PI / 2);
                    velocityX -= 2 * PLAYER_ACCELERATION * Math.cos(playerA + Math.PI / 2);
                }
                
                //Calculate speed (with capping)
                var movementV = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                if (movementV > PLAYER_WALKING_SPEED) {
                    var ratioToCapSpeed = PLAYER_WALKING_SPEED / movementV;
                    velocityX *= ratioToCapSpeed;
                    velocityY *= ratioToCapSpeed;
                    movementV = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                }

                //Calculate angle
                if (velocityX === 0 && velocityY >= 0)
                    var movementA = Math.PI / 2;
                else if (velocityX === 0 && velocityY < 0)
                    var movementA = 3 * Math.PI / 2;
                else if (velocityX >= 0)
                    var movementA = Math.atan(velocityY / velocityX);
                else
                    var movementA = Math.atan(velocityY / velocityX) + Math.PI;
                    
                //Move
                tryMove(movementA, movementV * elapsedTime);
            }

            function tryMove(angle, walkDistance) {

                //Get distances
                var distX = Math.cos(angle) * walkDistance;
                var distY = Math.sin(angle) * walkDistance;

                //Get hits
                var hitX = raycastingEngine.getFirstHitForDirection(angle, false);
                var hitY = raycastingEngine.getFirstHitForDirection(angle, true);

                //Try move straight
                if (hitX.dist > walkDistance && hitY.dist > walkDistance) {
                    playerX += distX;
                    playerY += distY;
                }
                //Try move along wall
                else if (hitX.dist < hitY.dist) {
                    if (distY > 0)
                        tryMove(Math.PI / 2, distY);
                    else if (distY < 0)
                        tryMove(3 * Math.PI / 2, -distY);
                }
                else if (hitX.dist > hitY.dist) {
                    if (distX > 0)
                        tryMove(0, distX);
                    else if (distX < 0)
                        tryMove(Math.PI, -distX);
                }
            }

            function pushPlayerDownIfNecessary() {                    
                if (Math.floor(playerX) !== playerX) {
                    if (world[Math.floor(playerY - PLAYER_PUSHED_BUFFER)][Math.floor(playerX)] === WALL_TYPE_PIECE_ACTIVE)
                        playerY = Math.floor(playerY - PLAYER_PUSHED_BUFFER) - PLAYER_PUSHED_BUFFER;
                }
                else if (Math.floor(playerX) === playerX) {
                    if (world[Math.floor(playerY - PLAYER_PUSHED_BUFFER)][Math.floor(playerX)] === WALL_TYPE_PIECE_ACTIVE || world[Math.floor(playerY - PLAYER_PUSHED_BUFFER)][Math.floor(playerX) - 1] === WALL_TYPE_PIECE_ACTIVE)
                        playerY = Math.floor(playerY - PLAYER_PUSHED_BUFFER) - PLAYER_PUSHED_BUFFER;
                }
                handleSmashIfNecessary();
            }

            function pushPlayerLeftIfNecessary() {                    
                if (Math.floor(playerY) !== playerY) {
                    if (world[Math.floor(playerY)][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE)
                        playerX = Math.floor(playerX - PLAYER_PUSHED_BUFFER) - PLAYER_PUSHED_BUFFER;
                }
                else if (Math.floor(playerY) === playerY) {
                    if (world[Math.floor(playerY)][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE || world[Math.floor(playerY) - 1][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE)
                        playerX = Math.floor(playerX - PLAYER_PUSHED_BUFFER) - PLAYER_PUSHED_BUFFER;
                }
                handleSmashIfNecessary();
            }

            function pushPlayerRightIfNecessary() {              
                if (Math.floor(playerY) !== playerY) {
                    if (world[Math.floor(playerY)][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE)
                        playerX = Math.ceil(playerX + PLAYER_PUSHED_BUFFER) + PLAYER_PUSHED_BUFFER;
                }
                else if (Math.floor(playerY) === playerY) {
                    if (world[Math.floor(playerY)][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE || world[Math.floor(playerY) - 1][Math.floor(playerX - PLAYER_PUSHED_BUFFER)] === WALL_TYPE_PIECE_ACTIVE)
                        playerX = Math.ceil(playerX + PLAYER_PUSHED_BUFFER) + PLAYER_PUSHED_BUFFER;
                }
                handleSmashIfNecessary();
            }

            function pushPlayerToClosestAdjacentIfNecessary() {
                if (world[Math.floor(playerY)][Math.floor(playerX)] === WALL_TYPE_PIECE_ACTIVE) {
                    var pushOptions = [];

                    //Add side directions
                    var pushOption = new PushOption(Math.floor(playerX) + 1 + PLAYER_PUSHED_BUFFER, playerY);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(Math.floor(playerX) - 1 - PLAYER_PUSHED_BUFFER, playerY);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(playerX, Math.floor(playerY) + 1 + PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(playerX, Math.floor(playerY) - 1 - PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;

                    //Add diagonal directions
                    pushOption = new PushOption(Math.floor(playerX) + 1 + PLAYER_PUSHED_BUFFER, Math.floor(playerY) + 1 + PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(Math.floor(playerX) + 1 + PLAYER_PUSHED_BUFFER, Math.floor(playerY) - 1 - PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(Math.floor(playerX) - 1 - PLAYER_PUSHED_BUFFER, Math.floor(playerY) + 1 + PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;
                    pushOption = new PushOption(Math.floor(playerX) - 1 - PLAYER_PUSHED_BUFFER, Math.floor(playerY) - 1 - PLAYER_PUSHED_BUFFER);
                    if (pushOption.wallType === WALL_TYPE_NONE)
                        pushOptions[pushOptions.length] = pushOption;

                    //Sort
                    pushOptions.sort(function (a, b) { return a.getDistanceToPlayer() - b.getDistanceToPlayer(); } );

                    //Move player
                    if (pushOptions.length > 0) {
                        playerX = pushOptions[0].x;
                        playerY = pushOptions[0].y;
                    }
                }

                function PushOption(x, y) {

                    //Set coordinates
                    this.x = x;                    
                    this.y = y;

                    //Ensure bounds
                    if (this.x < 0)
                        this.x = PLAYER_PUSHED_BUFFER;
                    if (this.x >= world[0].length)
                        this.x = world[0].length - PLAYER_PUSHED_BUFFER;
                    if (this.y < 0)
                        this.y = PLAYER_PUSHED_BUFFER;
                    if (this.y >= world.length)
                        this.y = world.length - PLAYER_PUSHED_BUFFER;

                    this.wallType = world[Math.floor(this.y)][Math.floor(this.x)];
                    this.getDistanceToPlayer = function () { return Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2)); };
                }
            }

            function handleSmashIfNecessary() {

                //Is player smashed?
                var isSmashed;
                var playerXFloor = Math.floor(playerX);
                var playerYFloor = Math.floor(playerY);
                if (playerXFloor !== playerX) {
                    if (playerYFloor !== playerY) {
                        isSmashed = world[playerYFloor][playerXFloor] !== WALL_TYPE_NONE;
                    }
                    else if (playerYFloor === playerY) {
                        isSmashed = world[playerYFloor][playerXFloor] !== WALL_TYPE_NONE
                            && world[playerYFloor - 1][playerXFloor] !== WALL_TYPE_NONE;
                    }
                }
                else if (playerXFloor === playerX) {
                    if (playerYFloor !== playerY) {
                        isSmashed = world[playerYFloor][playerXFloor] !== WALL_TYPE_NONE
                            && world[playerYFloor][playerXFloor - 1] !== WALL_TYPE_NONE;
                    }
                    else if (playerYFloor === playerY) {
                        isSmashed = world[playerYFloor][playerXFloor] !== WALL_TYPE_NONE
                            && world[playerYFloor][playerXFloor - 1] !== WALL_TYPE_NONE
                            && world[playerYFloor - 1][playerXFloor] !== WALL_TYPE_NONE
                            && world[playerYFloor - 1][playerXFloor - 1] !== WALL_TYPE_NONE;
                    }
                }

                //Handle smash
                if (isSmashed) {
                    console.log("Player was smashed!");
                    isGameExecuting = false;
                }
            }

            function playerLostTetris() {                
                console.log("Player lost Tetris!");
                isGameExecuting = false;
            }

            function isFacingRight () {
                return (playerA > (3/2)*Math.PI)
                    || (playerA < (1/2)*Math.PI);
            };

            function isFacingUp () {
                return playerA > Math.PI;
            };

            function attachMouseListeners(){
                var oldX;
                document.addEventListener('mousemove', function(e){
                    if(oldX == null){
                        oldX = e.screenX;
                    }
                    console.log(e);
                    if(e.screenX > oldX){
                        //moving left
                        console.log('left');
                    }
                    if(e.screenX < oldX){
                        //move right
                        console.log('ri');
                    }
                    oldX = e.screenX;
                }, false);

                document.addEventListener('click', function(e){
                    console.log('click');
                }, false);
            }

            function attachKeyboardListeners() {

                //Key down
                document.onkeydown = function (keyboardEvent) {
                    if (isGameExecuting) {
                        switch (keyboardEvent.keyCode) {
                            case 87: //W
                                isMovingForward = true;
                                break;
                            case 65: //A
                                isTurningLeft = true;
                                break;
                            case 81: //Q
                                isSidesteppingLeft = true;
                                break;
                            case 69: //E
                                isSidesteppingRight = true;
                                break;
                            case 83: //S
                                isMovingBackward = true;
                                break;
                            case 68: //D
                                isTurningRight = true;
                                break;
                            case 37: //Right arrow
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE) {
                                    if (isFacingUp()) {
                                        tetrisEngine.moveRight();
                                        pushPlayerRightIfNecessary();
                                    }
                                    else {
                                        tetrisEngine.moveLeft();
                                        pushPlayerLeftIfNecessary();
                                    }
                                }
                                break;
                            case 38: //Up arrow
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE) {
                                    if (isFacingRight()) {
                                        tetrisEngine.moveRight();
                                        pushPlayerRightIfNecessary();
                                    }
                                    else {
                                        tetrisEngine.moveLeft();
                                        pushPlayerLeftIfNecessary();
                                    }
                                }
                                break;
                            case 39: //Left arrow
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE) {
                                    if (isFacingUp()) {
                                        tetrisEngine.moveLeft();
                                        pushPlayerLeftIfNecessary();
                                    }
                                    else {
                                        tetrisEngine.moveRight();
                                        pushPlayerRightIfNecessary();
                                    }
                                }
                                break;
                            case 40: //Down arrow
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE) {
                                    if (isFacingRight()) {
                                        tetrisEngine.moveLeft();
                                        pushPlayerLeftIfNecessary();
                                    }
                                    else {
                                        tetrisEngine.moveRight();
                                        pushPlayerRightIfNecessary();
                                    }
                                }
                                break;
                            case 191: //Forward slash
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE)
                                    tetrisEngine.rotate(-1);
                                    pushPlayerToClosestAdjacentIfNecessary();
                                break;
                            case 190: //Peroid
                                if (raycastingEngine.getWallType(playerA) === WALL_TYPE_PIECE_ACTIVE)
                                    tetrisEngine.rotate(1);
                                    pushPlayerToClosestAdjacentIfNecessary();
                                break;
                            case 32: //Space
                                isDropping = true;
                                break;
                        }
                    }
                }

                //Key up
                document.onkeyup = function (keyboardEvent) {
                    if (isGameExecuting) {
                        switch (keyboardEvent.keyCode) {
                            case 87: //W
                                isMovingForward = false;
                                break;
                            case 65: //A
                                isTurningLeft = false;
                                break;
                            case 81: //Q
                                isSidesteppingLeft = false;
                                break;
                            case 69: //E
                                isSidesteppingRight = false;
                                break;
                            case 83: //S
                                isMovingBackward = false;
                                break;
                            case 68: //D
                                isTurningRight = false;
                                break;
                            case 32: //Space
                                isDropping = false;
                                break;
                        }
                    }
                }
            }
        }


        ///////////////////////
        // Raycasting engine //
        ///////////////////////

        function RaycastingEngine() {
            var self = this;


            //-- PRIVATE MEMBER CONSTANTS --//   

            var TICK_DELAY = 1000 / MAX_FRAMERATE;  


            //-- PRIVATE MEMBER CONSTANTS --//

            var VERTICAL_WALL_COLORS = WALL_COLORS.map(function (color) { return shadeColor(color, WALL_SHADING_PERCENT); });   
            var VERTICAL_WALL_COLORS_FACING = WALL_COLORS_FACING.map(function (color) { return shadeColor(color, WALL_SHADING_PERCENT); });   
            var WORLD_LENGTH_X = world[0].length;
            var WORLD_LENGTH_Y = world.length;
            var HALF_VIEWPORT_ANGLE_RADIANS = (VIEWPORT_WIDTH_DEGREES - 180) * Math.PI / -360;
            var VIEWPORT_DIST = Math.tan(HALF_VIEWPORT_ANGLE_RADIANS) * .5;


            //-- PUBLIC METHODS --//

            self.getWallType = function (angle) {
                var firstHit = getFirstHit(angle);
                return firstHit.wallType;
            };

            self.getFirstHitForDirection = function (angle, onHorizontalWalls) {

                //configure direction
                if (onHorizontalWalls) {
                    var divisorToGetDist = Math.sin(angle);
                    var primaryCoordinate = playerY;
                    var secondaryCoordinate = playerX;
                    var multiplierToGetSecondary = 1 / Math.tan(angle);
                    var primaryMaxLength = WORLD_LENGTH_Y;
                    var secondaryMaxLength = WORLD_LENGTH_X;
                    var getWallTypeAtIntLocation = function () { return world[primaryInt + primaryWorldOffset][secondaryInt]; };
                }
                else {
                    var divisorToGetDist = Math.cos(angle);
                    var primaryCoordinate = playerX;
                    var secondaryCoordinate = playerY;
                    var multiplierToGetSecondary = Math.tan(angle);
                    var primaryMaxLength = WORLD_LENGTH_X;
                    var secondaryMaxLength = WORLD_LENGTH_Y;
                    var getWallTypeAtIntLocation = function () { return world[secondaryInt][primaryInt + primaryWorldOffset]; };
                }

                //Look for first hit
                if (divisorToGetDist != 0) {
                    var angleIsPositive = divisorToGetDist >= 0;
                    var firstPrimaryInt = angleIsPositive ? Math.ceil(primaryCoordinate) : Math.floor(primaryCoordinate);
                    var intStep = angleIsPositive ? 1 : -1;
                    var primaryWorldOffset = angleIsPositive ? 0 : -1;

                    //Test each grid intercept
                    for (var primaryInt = firstPrimaryInt ; primaryInt < primaryMaxLength; primaryInt += intStep) {
                        var primaryDist = primaryInt - primaryCoordinate;
                        var secondaryInt = Math.floor(secondaryCoordinate + primaryDist * multiplierToGetSecondary);

                        //If a hit
                        if (secondaryInt <= 0 || secondaryInt >= secondaryMaxLength || primaryInt <= 0 || primaryInt >= primaryMaxLength) {
                            break;
                        }
                        else if (getWallTypeAtIntLocation() !== WALL_TYPE_NONE) {
                            var distHit = primaryDist / divisorToGetDist;

                            //Return hit object
                            return { 
                                dist: distHit, 
                                wallType: getWallTypeAtIntLocation(), 
                                isHorizontalWall: onHorizontalWalls
                            };
                        }
                    }
                }

                //No hit found
                return { 
                    dist: Infinity,
                    wallType: null,
                    horizontalWall: onHorizontalWalls
                };
            };


            //-- CONSTRUCTOR CODE --//

            (function () {
                var canvasContext = initializeAndGetCanvasContext();
                executeAndScheduleTick(new Date().valueOf(), canvasContext);
            })();


            //-- PRIVATE METHODS --//
            
            function executeAndScheduleTick(lastTickTime, canvasContext) {
                
                //Schedule next tick
                var currentTickTime = new Date().valueOf();
                setTimeout(function () {
                    executeAndScheduleTick(currentTickTime, canvasContext); 
                }, TICK_DELAY);

                //Draw
                drawScreen(canvasContext);
            }
            
            function initializeAndGetCanvasContext() {
                var canvas = document.getElementById("canvas");
                canvas.setAttribute("width", VIEWPORT_WIDTH_PIXELS);
                canvas.setAttribute("height", VIEWPORT_HEIGHT_PIXELS);
                var context = canvas.getContext("2d");
                context.lineWidth = COLUMN_WIDTH_PIXELS;
                return context;
            }

            function drawScreen(canvasContext) {
                var facingWallType = self.getWallType(playerA);

                //For each viewport column
                for (var col = 0; col < VIEWPORT_WIDTH_PIXELS; col += COLUMN_WIDTH_PIXELS) {

                    //Get angle for column
                    var angleRelativeToPlayer = Math.atan((.5 - col / VIEWPORT_WIDTH_PIXELS) / VIEWPORT_DIST);
                    var angleRelativeToWorld = playerA + angleRelativeToPlayer;

                    //Get wall hit
                    var firstHit = getFirstHit(angleRelativeToWorld)
                    var firstHitDist = firstHit.dist;
                    var firstHitWallType = firstHit.wallType;
                    var isFirstHitHorizontalWall = firstHit.isHorizontalWall;

                    //Correct distortion due to flat viewport
                    var distFromViewport = firstHitDist * Math.cos(angleRelativeToPlayer);

                    //Get wall height on viewport
                    var wallHeightOnViewport;
                    if (distFromViewport != 0)
                        wallHeightOnViewport = WALL_HEIGHT * VIEWPORT_HEIGHT_PIXELS / distFromViewport;
                    else
                        wallHeightOnViewport = VIEWPORT_HEIGHT_PIXELS;
                    if (wallHeightOnViewport > VIEWPORT_HEIGHT_PIXELS)
                        wallHeightOnViewport = VIEWPORT_HEIGHT_PIXELS;

                    //Draw column
                    drawColumn(canvasContext, col, wallHeightOnViewport, firstHitWallType, isFirstHitHorizontalWall, distFromViewport * WALL_DISTANCE_SHADE, facingWallType);
                }

                //Draw overhead map
                for (var row = 0; row < world.length; row++) {
                    for (var col = 0; col < world[0].length; col++) {
                        var color = world[row][col] === 0 ? "#FFFFFF" : WALL_COLORS[world[row][col] - 1];
                        canvasContext.fillStyle = color;
                        canvasContext.fillRect(col * 10, VIEWPORT_HEIGHT_PIXELS - row * 10 - 10, 10, 10);
                        canvasContext.stroke();
                    }
                }
                canvasContext.fillStyle = "#000000";
                canvasContext.fillRect(playerX * 10 - 1, VIEWPORT_HEIGHT_PIXELS - playerY * 10 - 1, 3, 3);
                canvasContext.stroke();
                var leftRayA = playerA + Math.atan(.5 / VIEWPORT_DIST);
                var leftRayX = playerX + 3 * Math.cos(leftRayA);
                var leftRayY = playerY + 3 * Math.sin(leftRayA);
                drawLine(canvasContext, playerX * 10, VIEWPORT_HEIGHT_PIXELS - playerY * 10, leftRayX * 10, VIEWPORT_HEIGHT_PIXELS - leftRayY * 10, "#BBBBBB");
                var rightRayA = playerA + Math.atan(-.5 / VIEWPORT_DIST);
                var rightRayX = playerX + 3 * Math.cos(rightRayA);
                var rightRayY = playerY + 3 * Math.sin(rightRayA);
                drawLine(canvasContext, playerX * 10, VIEWPORT_HEIGHT_PIXELS - playerY * 10, rightRayX * 10, VIEWPORT_HEIGHT_PIXELS - rightRayY * 10, "#BBBBBB");

                //Draw crosshairs
                drawLine(canvasContext, VIEWPORT_WIDTH_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2 - VIEWPORT_CROSSHAIR_SIZE_PIXELS / 2, VIEWPORT_WIDTH_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2 + VIEWPORT_CROSSHAIR_SIZE_PIXELS / 2, VIEWPORT_CROSSHAIR_COLOR);
                drawLine(canvasContext, VIEWPORT_WIDTH_PIXELS / 2 - VIEWPORT_CROSSHAIR_SIZE_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2, VIEWPORT_WIDTH_PIXELS / 2 + VIEWPORT_CROSSHAIR_SIZE_PIXELS / 2, VIEWPORT_HEIGHT_PIXELS / 2, VIEWPORT_CROSSHAIR_COLOR);
            }

            function getFirstHit(angle) {
                var hitX = self.getFirstHitForDirection(angle, false);
                var hitY = self.getFirstHitForDirection(angle, true);
                var isFirstHitHorizontalWall = hitY.dist < hitX.dist;
                return isFirstHitHorizontalWall ? hitY : hitX;
            }

            function drawColumn(canvasContext, col, wallHeight, wallType, isHorizontalWall, wallShade, facingWallType) {

                //Get wall position
                var wallTop = (VIEWPORT_HEIGHT_PIXELS - wallHeight) / 2;
                var wallBottom = VIEWPORT_HEIGHT_PIXELS - wallTop;

                //Get wall color
                var wallColor;
                if (wallType === facingWallType)
                    wallColor = isHorizontalWall ? WALL_COLORS_FACING[wallType - 1] : VERTICAL_WALL_COLORS_FACING[wallType - 1];
                else
                    wallColor = isHorizontalWall ? WALL_COLORS[wallType - 1] : VERTICAL_WALL_COLORS[wallType - 1];

                //Draw column
                drawLine(canvasContext, col, 0, col, wallTop, SKY_COLOR);
                drawLine(canvasContext, col, wallTop, col, wallBottom, shadeColor(wallColor, wallShade));
                drawLine(canvasContext, col, wallBottom, col, VIEWPORT_HEIGHT_PIXELS, GROUND_COLOR);
            }

            function drawLine(canvasContext, x1, y1, x2, y2, color) {
                canvasContext.beginPath();
                canvasContext.strokeStyle = color;
                canvasContext.moveTo(x1, y1);
                canvasContext.lineTo(x2, y2);
                canvasContext.stroke();
            }
            
            function shadeColor(color, percent) {
				
				//There is a bug where these are sometimes undefined when the player gets smashed
				//This is a hacky fix, that will hopefully be temporary
                if (!color)
                    color = "#000000";
                if (!percent)
                    percent = 1;

                //From: http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
                var num = parseInt(color.slice(1), 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, G = (num >> 8 & 0x00FF) + amt, B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        };

        
        ///////////////////
        // Tetris engine //
        ///////////////////

        function TetrisEngine() {
            var self = this;


            //-- PRIVATE MEMBER VARIABLES --//

            var lastTickIndex = 0;
            var tickDelay = TETRIS_STARTING_TICK_SPEED_MILLISECONDS;
            var numberOfLines = 0;
            var currentLevel = TETRIS_STARTING_LEVEL;
            var currentRotation = 0; //goes from 0 - 3, which says where the blank line is it rotates around.
            var score = 0;
            var currentTetrisBlock;

            //-- PUBLIC METHODS --//

            self.getNumberOfLines = function () {
                return numberOfLines;
            }

            self.getScore = function () {
                return score;
            }

            self.getLevel = function () {
                return currentLevel;
            }

            self.moveLeft = function () {
                console.log("Move Tetris piece left.");
                var newWorld = createNewWorld();
                for(var rowIndex = 0; rowIndex < newWorld.length; rowIndex++){
                    for(var cellIndex =0; cellIndex < newWorld[rowIndex].length; cellIndex++){
                        var currentCell = newWorld[rowIndex][cellIndex];

                        if(currentCell == WALL_TYPE_PIECE_ACTIVE){
                            newWorld[rowIndex][cellIndex-1] = WALL_TYPE_PIECE_ACTIVE; //move it 'left'
                            newWorld[rowIndex][cellIndex] = WALL_TYPE_NONE; //displace the old cell
                        }
                    }
                }

                if(isNewWorldValid(newWorld)){
                    world = newWorld;
                }

            };

            self.moveRight = function () {
                console.log("Move Tetris piece right.");

                var newWorld = createNewWorld();
                for(var rowIndex = 0; rowIndex < newWorld.length; rowIndex++){
                    for(var cellIndex = newWorld[rowIndex].length; cellIndex >= 0; cellIndex--){ //starts from the right side of each array
                        var currentCell = newWorld[rowIndex][cellIndex];
                        if(currentCell == WALL_TYPE_PIECE_ACTIVE){
                            newWorld[rowIndex][cellIndex+1] = WALL_TYPE_PIECE_ACTIVE; //move it 'right'
                            newWorld[rowIndex][cellIndex] = WALL_TYPE_NONE; //displace the old cell
                        }
                    }
                }

                if(isNewWorldValid(newWorld)){
                    world = newWorld;
                }

            };

            self.rotate = function (angle) {
                angle = angle || 1;
                angle = angle > 0 ? 1 : -1;
                
                console.log("Rotate Tetris piece.");

                //http://tetris.wikia.com/wiki/SRS
                //now using premade block rotation matrices
                //we'll find the center, and then throw on new rotation (kept track by the var currentRotation) 
                //and we'll remove the current peice, and put in the rotation
                if(currentTetrisBlock.name == "O"){
                    //we don't spin no 0s
                    return;
                }

                var center = []; //the center which will be rotated around
                if("TLJI".indexOf(currentTetrisBlock.name) >= 0)  //the following finds the center of the current piece in the world for TLJI pieces
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex <= world[rowIndex].length; cellIndex++){
                        if(world[rowIndex][cellIndex] == 2){
                            if((world[rowIndex-1][cellIndex] == WALL_TYPE_PIECE_ACTIVE 
                              && world[rowIndex+1][cellIndex] == WALL_TYPE_PIECE_ACTIVE) //left-right are 2's
                            || (world[rowIndex][cellIndex-1] == WALL_TYPE_PIECE_ACTIVE 
                              && world[rowIndex][cellIndex+1] == WALL_TYPE_PIECE_ACTIVE)){ //up-down are 2's
                                center = [rowIndex, cellIndex];
                            }
                        }
                    }
                }
                if("SZ".indexOf(currentTetrisBlock.name) >= 0) { //piece is either S or Z (which we have to find all of the piece, and the rotation we're in, to make sure it's the right center.)
                    for(var y = 0; y < world.length; y++){
                        for(var x = 0; x <= world[y].length; x++){
                            if(world[y][x] == WALL_TYPE_PIECE_ACTIVE){
                                //basically, we're gonna spin around different squares, given the currentRotation we're on
                                // so we gotta find the 'center' for each piece/rotation.
                                if(currentTetrisBlock.name == "S"){
                                    if(currentRotation == 0
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x-1]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                                    if(currentRotation == 1
                                    && world[y+1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                                    if(currentRotation == 2 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x-1]==WALL_TYPE_PIECE_ACTIVE)
                                       {center = [y,x];}
                                    if(currentRotation == 3 
                                    && world[y+1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                       {center = [y,x];}
                                }
                                if(currentTetrisBlock.name == "Z"){
                                    if(currentRotation == 0
                                    && world[y][x-1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                                    if(currentRotation == 1 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y+1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                       {center = [y,x];}
                                    if(currentRotation == 2 
                                    && world[y][x-1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y-1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                                    if(currentRotation == 3 
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y+1][x+1]==WALL_TYPE_PIECE_ACTIVE)
                                       {center = [y,x];}
                                }
                            }
                        }
                    }
                }

                console.log(center);

                if(currentTetrisBlock.name == "I") {
                     for(var y = 0; y < world.length; y++){
                        for(var x = 0; x <= world[y].length; x++){
                            if(world[y][x] == WALL_TYPE_PIECE_ACTIVE){
                                if(currentRotation%2 == 0
                                    && world[y][x-1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+1]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y][x+2]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                                if(currentRotation%2 == 1
                                    && world[y-1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y+1][x]==WALL_TYPE_PIECE_ACTIVE 
                                    && world[y+2][x]==WALL_TYPE_PIECE_ACTIVE)
                                        {center = [y,x];}
                            }
                        }
                     }
                }

                if(center.length == 0){
                    console.log("We don't have a center, so we won't rotate");
                    //this is more error handling than anything, we SHOULD have a center, but I'm not certain all my matricies are 
                    // well specified above (or in the original TETRIS_X objects)
                    return;
                }

                //we now know the center, which is the cell with a block we're going to project our new rotated matrix onto
                var rotationType = angle > 0 ? 1 : -1;
                if(currentRotation+rotationType < 0){
                    rotationType+= 4;
                }
                var newRotation = (currentRotation+rotationType)%4;

                var rotatedMatrix = currentTetrisBlock.rotations[newRotation];

                var newWorld = createNewWorld();
                //clear the world, then build it with rotated piece in its new place
                for(var r = 0; r<newWorld.length; r++){
                    for(var c=0; c<newWorld[r].length; c++){
                        if(newWorld[r][c]==WALL_TYPE_PIECE_ACTIVE){
                            newWorld[r][c] = WALL_TYPE_NONE;
                        }
                    }
                }
                //put in the new piece.
                if(currentTetrisBlock.name == "I"){
                    //the 4x4 block is so weird, I'm just going to hardcode the piece placement. -af
                    if(newRotation%2 == 1){ //vertical
                        newWorld[center[0]+2][center[1]] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]+1][center[1]] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]][center[1]] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]-1][center[1]] = WALL_TYPE_PIECE_ACTIVE;
                    }
                    else{ //horizontal
                        newWorld[center[0]][center[1]-1] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]][center[1]] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]][center[1]+1] = WALL_TYPE_PIECE_ACTIVE;
                        newWorld[center[0]][center[1]+2] = WALL_TYPE_PIECE_ACTIVE;
                    }

                }
                else{ //for all other pieces we can use a 3x3 grid.
                    for(var rowIndex = 0; rowIndex < rotatedMatrix.length; rowIndex++){
                        var offset = -1; //offset so in our 3x3 matrix [1,1] is now the center;
                        for(var cellIndex = 0; cellIndex < rotatedMatrix[rowIndex].length; cellIndex++){
                            if(rotatedMatrix[rowIndex][cellIndex] == WALL_TYPE_PIECE_ACTIVE){
                                
                                var y_coord = center[0] + rowIndex + offset; 
                                var x_coord = center[1] + cellIndex + offset; 
                                newWorld[y_coord][x_coord] = WALL_TYPE_PIECE_ACTIVE;
                            }
                        }
                    }
                }

                if(isNewWorldValid(newWorld)){
                    world = newWorld;
                    currentRotation = newRotation;
                }
                
     
            };

            self.drop = function () {

                //Set speed
                if (tickDelay > TETRIS_DROP_TICK_SPEED_MILLISECONDS)
                    tickDelay = TETRIS_DROP_TICK_SPEED_MILLISECONDS;

                //Immediately initiate tetris tick
                scheduleTick(0);
            };

            self.cancelDrop = function () {

                //Update the speed
                var oldTickDelay = tickDelay;
                updateSpeedIfNecessary();

                //Reset the tick if speed was updated
                if (tickDelay != oldTickDelay)
                    scheduleTick(tickDelay);
            };

            self.pieceMovedDownCallback = null;

            self.playerLostCallback = null;


            //-- CONSTRUCTOR CODE --//

            (function () {
                addBlock();
                scheduleTick(0);
            })();


            //-- PRIVATE METHODS --//

            function executeAndScheduleTick(initiatingTickIndex) {
                if (isGameExecuting && initiatingTickIndex === lastTickIndex) {
                    scheduleTick(tickDelay);
                    
                    if(isMovingDownACollision()){
                        setPiece();
                        clearLines();
                        updateSpeedIfNecessary();
                        addBlock();
                        scheduleTick(tickDelay);
                    }
                    else{
                        movePieceDown();
                    }
                }
            }

            function scheduleTick(delay) {            
                var currentTickIndex = lastTickIndex + 1;
                lastTickIndex = currentTickIndex;            
                setTimeout(function () { executeAndScheduleTick(currentTickIndex); }, delay);
            }

            function addBlock(){
                

                currentTetrisBlock = TETRIS_PIECES[Math.floor(Math.random()*(TETRIS_PIECES.length))]; //shuffle the pieces and grab one
                var newBlock = currentTetrisBlock.initial; 
                var length = newBlock[0].length;
                var startingCell = (10/2)-Math.floor(length/2);
                for(var rowIndex = 0; rowIndex < newBlock.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex < newBlock[rowIndex].length; cellIndex++){
                        //if the cell is already filled, game over.
                        var yLocation = world.length-2; // -2 for the 2 edge pieces in the world array
                        yLocation = yLocation-rowIndex; //move down another row for each rowIndex

                        var xLocation = startingCell+cellIndex; //the middle of the screen plus the index we're at on the new piece

                        if(world[yLocation][xLocation] == WALL_TYPE_PIECE_INACTIVE){ 
                            if (self.playerLostCallback !== null){
                                console.log("LOST: all filled up");
                                self.playerLostCallback();
                            }
                        }else{ //place the new block;
                            world[yLocation][xLocation] = newBlock[rowIndex][cellIndex];
                        }
                        
                    }                    
                }
                currentRotation = 0;
                
            }

            function movePieceDown(){
                //nothing colides, so we can move it down;
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    for(var cellIndex =0; cellIndex < world[rowIndex].length; cellIndex++){
                        var currentCell = world[rowIndex][cellIndex];
                        if(currentCell == WALL_TYPE_PIECE_ACTIVE){
                            world[rowIndex-1][cellIndex] = WALL_TYPE_PIECE_ACTIVE; //move it 'down'
                            world[rowIndex][cellIndex] = WALL_TYPE_NONE; //displace the old cell
                        }
                    }
                }
                //execute possible callback
                if (self.pieceMovedDownCallback !== null)
                    self.pieceMovedDownCallback();
            }

            function setPiece(){
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex < world[rowIndex].length; cellIndex++){
                        var currentCell = world[rowIndex][cellIndex];
                        if(currentCell == WALL_TYPE_PIECE_ACTIVE){
                            world[rowIndex][cellIndex] = WALL_TYPE_PIECE_INACTIVE;
                        }
                    }
                }
            }           

            function clearLines(){
                //find all the rows to remove
                var rowsToRemove = [];
                for(var rowIndex = 0; rowIndex < world.length; rowIndex++){
                    if(world[rowIndex].reduce((a,b)=>a+b,0)== 32){ //row is [1,3,3,3,3,3,3,3,3,3,3,1], sums to 32
                        rowsToRemove.push(rowIndex);
                    }
                }

                var numLinesToScore =rowsToRemove.length;
                var pointsPerLine = [0, 40, 100, 300, 1200]; //how many points per num lines (0 lines, 0 points, 0 crates.)
                //update score
                //	40 * (n + 1)	100 * (n + 1)	300 * (n + 1)	1200 * (n + 1) (this is how to calc score, which I never knew)
                score = score + (pointsPerLine[numLinesToScore] * (currentLevel+1));

                //remove lines
                for(var i =0; i <rowsToRemove.length; i++){
                    world.splice(rowsToRemove[i],1);  //remove that row
                    world.splice(20,0,[1,0,0,0,0,0,0,0,0,0,0,1]); //push a blank row at top
                    //add a line, and maybe speed up
                    numberOfLines++;
                    if(numberOfLines >= ((currentLevel*10)+10)){
                        currentLevel++;
                    }
                }

            }

            function isMovingDownACollision(){
                //find all the 2's and move them 'plus' one level in the array
                var collision = false;
                for(var rowIndex = world.length-1; rowIndex > 0; rowIndex--){ //start at the last row and work up
                    var currentRow = world[rowIndex];
                    for(var cellIndex = 0; cellIndex < currentRow.length; cellIndex++){
                        //for each cell, see if it's an active piece, and if we can move it down.
                        if(currentRow[cellIndex] == WALL_TYPE_PIECE_ACTIVE){
                            var cellBelowCurrentCell = world[rowIndex-1][cellIndex];
                            if(cellBelowCurrentCell == WALL_TYPE_ARENA ||
                                cellBelowCurrentCell == WALL_TYPE_PIECE_INACTIVE ){
                                    collision = true;
                                    return collision;
                                }
                        }
                    }
                }
                return collision;
            }

            function createNewWorld(){
                //creates a copy of the world and returns it.
                var newWorld =[
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ];

                for(var r = 0; r < newWorld.length; r++){
                    for(var c=0; c < newWorld[r].length; c++){
                        newWorld[r][c] = world[r][c];
                    }
                }
                return newWorld;
            }


            function isNewWorldValid (newWorld){
                //see if newWorld conflicts with the old world.
                for(var rowIndex = 0; rowIndex < newWorld.length; rowIndex++){
                    for(var cellIndex = 0; cellIndex < newWorld[rowIndex].length; cellIndex++){
                        if(newWorld[rowIndex][cellIndex] == WALL_TYPE_PIECE_ACTIVE){
                            if(world[rowIndex][cellIndex] == WALL_TYPE_ARENA 
                            || world[rowIndex][cellIndex] == WALL_TYPE_PIECE_INACTIVE){
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            function updateSpeedIfNecessary() {
                //updates the speed, used when dropping stops, and when the level goes up.
                tickDelay = TETRIS_STARTING_TICK_SPEED_MILLISECONDS - (currentLevel * TETRIS_SPEED_PER_LEVEL_MILLISECONDS);
            }
        }
        

        //////////////////////
        // Global functions //
        //////////////////////

        function overrideConfigConstants() {
            var callback;
            
            //Notify parent window that we're ready to receive config values
            parent.postMessage("ready", "*");

            //Get config values if posted
            window.addEventListener('message', function(event) {
                if (event.data !== "ready") {
                    isGameExecuting = true;
                    //Override
                    for (var key in event.data) {
                        if (event.data.hasOwnProperty(key)) {
                            window[key] = event.data[key];
                        }
                    }
                    callback();
                }
            });

            //After a while, give up on config values and start the game anyways
            setTimeout(function() {
                if (!isGameExecuting) {
                    isGameExecuting = true;
                    callback();
                }
            }, CONFIG_VALUE_WAIT_TIME_MILLISECONDS);  

            //Return promise
            return {then: function (promiseCallback) {
                callback = promiseCallback;
            }};
        }
    </script>
</body>
</html>